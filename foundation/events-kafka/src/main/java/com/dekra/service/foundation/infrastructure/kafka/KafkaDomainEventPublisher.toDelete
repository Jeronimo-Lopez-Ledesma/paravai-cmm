package com.dekra.service.foundation.infrastructure.kafka;

import com.dekra.service.foundation.domaincore.event.DomainEvent;
import com.dekra.service.foundation.domaincore.event.ReactiveDomainEventPublisher;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.common.header.internals.RecordHeaders;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;
import reactor.kafka.sender.KafkaSender;
import reactor.kafka.sender.SenderRecord;

import java.util.List;

@Deprecated(forRemoval = true)
@Component
@ConditionalOnProperty(name = "kafka.enabled", havingValue = "true", matchIfMissing = true)
public class KafkaDomainEventPublisher implements ReactiveDomainEventPublisher {

    private static final Logger log = LoggerFactory.getLogger(KafkaDomainEventPublisher.class);

    private final KafkaSender<String, DomainEvent> kafkaSender;
    private final KafkaTopicResolver topicResolver;

    public KafkaDomainEventPublisher(KafkaSender<String, DomainEvent> kafkaSender,
                                     KafkaTopicResolver topicResolver) {
        this.kafkaSender = kafkaSender;
        this.topicResolver = topicResolver;
    }

    @Override
    public <T extends DomainEvent> Mono<Void> publish(T event) {
        if (!event.getClass().isAnnotationPresent(PublishToKafka.class)) {
            log.warn("Event {} not published: missing @PublishToKafka annotation", event.getClass().getSimpleName());
            return Mono.empty();
        }

        String topic = topicResolver.resolve(event);
        String key = event.metadata().eventId().toString();

        ProducerRecord<String, DomainEvent> record = new ProducerRecord<>(
                topic, null, key, event, new RecordHeaders()
        );
        record.headers().add("eventType", event.getClass().getSimpleName().getBytes());

        SenderRecord<String, DomainEvent, String> senderRecord =
                SenderRecord.create(record, key);
        log.info("Preparing to send event {} to topic {}", event.getClass().getSimpleName(), topic);
        log.info("Event key: {}", key);

        return kafkaSender.send(Mono.just(senderRecord))
                .doOnNext(result -> log.info(
                        "Event {} successfully sent to topic {} with offset {}",
                        key, topic, result.recordMetadata().offset()
                ))
                .doOnError(e -> log.error("Failed to publish event {} to Kafka", key, e))
                .then();
    }

    @Override
    public Mono<Void> publishAll(List<? extends DomainEvent> events) {
        return Mono.when(events.stream().map(this::publish).toList());
    }
}
